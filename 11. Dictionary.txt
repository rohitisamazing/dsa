#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
// Structure to represent each node in the BST
struct Node {
string keyword; // Keyword of the dictionary
string meaning; // Meaning of the keyword
Node* left; // Left child
Node* right; // Right child
// Constructor
Node(string k, string m) : keyword(k), meaning(m), left(nullptr), right(nullptr) {}
};
// Function to insert a new keyword and meaning
Node* insert(Node* root, string keyword, string meaning) {
if (root == nullptr) {
return new Node(keyword, meaning); // Create a new node if root is null
}
if (keyword < root->keyword) {
root->left = insert(root->left, keyword, meaning); // Insert in the left subtree
} else if (keyword > root->keyword) {
root->right = insert(root->right, keyword, meaning); // Insert in the right subtree
}
return root;
}

// Function to search for a keyword in the BST
Node* search(Node* root, string keyword) {
if (root == nullptr || root->keyword == keyword) {
return root; // Return root if found or null if not found
}
if (keyword < root->keyword) {
return search(root->left, keyword); // Search in the left subtree
}
return search(root->right, keyword); // Search in the right subtree
}
// Function to find the node with minimum keyword (for deletion)
Node* findMin(Node* root) {
while (root && root->left) {
root = root->left; // Traverse left until the minimum node is found
}
return root;
}
// Function to delete a keyword and its meaning
Node* deleteNode(Node* root, string keyword) {
if (root == nullptr) return root; // Return null if root is empty
// Search for the keyword to be deleted
if (keyword < root->keyword) {
root->left = deleteNode(root->left, keyword); // Move left
} else if (keyword > root->keyword) {
root->right = deleteNode(root->right, keyword); // Move right
} else { // Found the node to be deleted
if (root->left == nullptr) {
Node* temp = root->right;
delete root; // Free the node
return temp; // Return the right child (or null)
} else if (root->right == nullptr) {
Node* temp = root->left;
delete root;
return temp; // Return the left child (or null)
}
// Node with two children: Get the inorder successor (smallest in the right subtree)
Node* temp = findMin(root->right);
root->keyword = temp->keyword; // Copy the inorder successor's content to this node
root->meaning = temp->meaning;
root->right = deleteNode(root->right, temp->keyword); // Delete the inorder successor
}
return root;

}
// Function to update the meaning of an existing keyword
void update(Node* root, string keyword, string newMeaning) {
Node* foundNode = search(root, keyword);
if (foundNode) {
foundNode->meaning = newMeaning; // Update the meaning
cout << "Meaning of '" << keyword << "' updated successfully.\n";
} else {
cout << "Keyword '" << keyword << "' not found in the dictionary.\n";
}
}
// Function for inorder traversal (ascending order)
void inorder(Node* root) {
if (root != nullptr) {
inorder(root->left); // Traverse left subtree
cout << root->keyword << ": " << root->meaning << endl; // Print current node
inorder(root->right); // Traverse right subtree
}
}
// Function for reverse inorder traversal (descending order)
void reverseInorder(Node* root) {
if (root != nullptr) {
reverseInorder(root->right); // Traverse right subtree
cout << root->keyword << ": " << root->meaning << endl; // Print current node
reverseInorder(root->left); // Traverse left subtree
}
}
// Function to calculate maximum comparisons to find a keyword
int maxComparisons(Node* root) {
if (root == nullptr) return 0;
int leftHeight = maxComparisons(root->left);
int rightHeight = maxComparisons(root->right);
return max(leftHeight, rightHeight) + 1; // Return the height of the tree
}
int main() {
Node* root = nullptr;
int choice;
string keyword, meaning;

do {
// Display menu
cout << "\nDictionary Menu:\n";
cout << "1. Add a new keyword\n";
cout << "2. Delete a keyword\n";
cout << "3. Update a keyword meaning\n";
cout << "4. Display dictionary (Ascending Order)\n";
cout << "5. Display dictionary (Descending Order)\n";
cout << "6. Find maximum comparisons for keyword search\n";
cout << "7. Exit\n";
cout << "Enter your choice: ";
cin >> choice;
switch (choice) {
case 1: // Add a new keyword
cout << "Enter keyword: ";
cin >> keyword;
cout << "Enter meaning: ";
cin.ignore();
getline(cin, meaning);
root = insert(root, keyword, meaning);
cout << "Keyword added successfully.\n";
break;
case 2: // Delete a keyword
cout << "Enter keyword to delete: ";
cin >> keyword;
root = deleteNode(root, keyword);
cout << "Keyword deleted successfully (if found).\n";
break;
case 3: // Update a keyword meaning
cout << "Enter keyword to update: ";
cin >> keyword;
cout << "Enter new meaning: ";
cin.ignore();
getline(cin, meaning);
update(root, keyword, meaning);
break;
case 4: // Display in ascending order
cout << "Dictionary in ascending order:\n";
inorder(root);
break;
case 5: // Display in descending order

cout << "Dictionary in descending order:\n";
reverseInorder(root);
break;
case 6: // Find maximum comparisons for search
cout << "Maximum comparisons for keyword search: " << maxComparisons(root) << endl;
break;
case 7: // Exit
cout << "Exiting program...\n";
break;
default:
cout << "Invalid choice, try again.\n";
}
} while (choice != 7);
return 0;
}